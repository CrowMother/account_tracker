class PositionTracker:
    """Track open positions and realized PnL using FIFO cost basis.

    Positions are keyed by ``symbol``, ``expiration`` and ``strike`` so that
    multiple option contracts for the same underlying can be tracked
    independently.
    """

    def __init__(self):
        # queue of lots per (symbol, expiration, strike)
        self.positions: dict[
            tuple[str, str, float], list[dict[str, float]]
        ] = {}
        # realized profit in dollars per key
        self.realized_pnl: dict[tuple[str, str, float], float] = {}
        # total cost basis for closed lots per key
        self.closed_basis: dict[tuple[str, str, float], float] = {}
        # average cost of currently open lots per key
        self.average_cost: dict[tuple[str, str, float], float] = {}

    @staticmethod
    def _build_key(
        symbol: str, expiration: str | None, strike: float | None
    ) -> tuple[str, str, float]:
        """Return a normalized composite key for internal dictionaries."""
        return (symbol, expiration or "", float(strike or 0.0))

    def add_trade(
        self,
        symbol: str,
        qty: float,
        price: float,
        side: str,
        expiration: str | None = None,
        strike: float | None = None,
    ) -> float | None:
        """Record a trade and update FIFO positions.

        Returns the dollar PnL generated by the trade when ``side`` is
        ``"SELL"``. ``None`` is returned for buy trades.

        Parameters
        ----------
        symbol: str
            The contract identifier.
        qty: float
            Quantity traded.
        price: float
            Trade price.
        side: str
            ``"BUY"`` to open/add, ``"SELL"`` to close.
        expiration: str | None, optional
            Option expiration date.
        strike: float | None, optional
            Option strike price.
        """
        side = side.upper()
        if side not in {"BUY", "SELL"}:
            raise ValueError("side must be BUY or SELL")

        key = self._build_key(symbol, expiration, strike)
        queue = self.positions.setdefault(key, [])
        if side == "BUY":
            queue.append({"qty": float(qty), "price": float(price)})
            self._update_average_cost(key)
            return None

        # SELL path - close existing lots using FIFO
        qty_remaining = float(qty)
        trade_pnl = 0.0
        while qty_remaining > 0:
            if not queue:
                raise ValueError(
                    f"Attempting to sell more than open quantity for {symbol}"
                )
            lot = queue[0]
            close_qty = min(qty_remaining, lot["qty"])
            lot["qty"] -= close_qty
            if lot["qty"] == 0:
                queue.pop(0)
            pnl = (price - lot["price"]) * close_qty
            trade_pnl += pnl
            self.realized_pnl[key] = self.realized_pnl.get(key, 0.0) + pnl
            self.closed_basis[key] = (
                self.closed_basis.get(key, 0.0) + lot["price"] * close_qty
            )
            qty_remaining -= close_qty
        self._update_average_cost(key)
        return trade_pnl

    def get_open_quantity(
        self,
        symbol: str,
        expiration: str | None = None,
        strike: float | None = None,
    ) -> float:
        """Return the remaining open quantity for the given contract."""
        key = self._build_key(symbol, expiration, strike)
        queue = self.positions.get(key, [])
        return sum(lot["qty"] for lot in queue)

    def calculate_pnl(
        self,
        symbol: str,
        expiration: str | None = None,
        strike: float | None = None,
    ) -> float:
        """Return realized profit/loss percentage for the given contract."""
        key = self._build_key(symbol, expiration, strike)
        basis = self.closed_basis.get(key, 0.0)
        if basis == 0:
            return 0.0
        return self.realized_pnl.get(key, 0.0) / basis * 100

    def _update_average_cost(self, key: tuple[str, str, float]) -> None:
        """Recalculate and store the average cost for ``key``."""
        queue = self.positions.get(key, [])
        total_qty = sum(lot["qty"] for lot in queue)
        if total_qty:
            total_cost = sum(lot["qty"] * lot["price"] for lot in queue)
            self.average_cost[key] = total_cost / total_qty
        else:
            self.average_cost[key] = 0.0

    def get_percent_gain(
        self,
        symbol: str,
        expiration: str | None = None,
        strike: float | None = None,
        current_price: float | None = None,
    ) -> float:ikqyog-codex/add-manual-test-scenarios-in-tests/manual_tests.md
        """Return the percent difference between the current price and
        the open average."""
        """Return percent difference between ``current_price`` and the
        average open cost."""
        codex
        key = self._build_key(symbol, expiration, strike)
        avg_price = self.average_cost.get(key, 0.0)
        if not avg_price:
            return 0.0
        if current_price is None:
            raise ValueError("current_price must be provided")
        return (float(current_price) - avg_price) / avg_price * 100
